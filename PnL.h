/****************************************************************************
*   Copyright (c) 2016 Ashraf Qadir All rights reserved.
*   Author: Ashraf Qadir, <ashraf.qadr@gmail.com>
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in
*    the documentation and/or other materials provided with the
*    distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
****************************************************************************/

/**
* @file PnL.h
* @brief Camera Pose Estimation from 3 3D-2D line correspondences
* This is an implementation of the geometric P3L problem described in the papers
* 1. "Pose Determination from Line-to-Plane Correspondences: Existance Condition and Closed Form Solutions"
* 2. "Pose Estimation from Line Correspondences: A Complete Analysis and A Series of Solutions"
* @author Ashraf Qadir, <ashraf.qadr@gmail.com>
*/
#pragma once

#ifndef PNL_H
#define PNL_H


#include <iostream>
#include <vector>
#include <math.h>
#include <unordered_map>
#include <cmath>
#include <numeric>
#include <QString>
#include <QDebug>
#include <Eigen/Core>
#include <Eigen/StdVector>
#include <Eigen/Dense>
#include <boost/concept_check.hpp>
#include <unsupported/Eigen/Polynomials>
//#include "MathHelper.h"
#include "Line2D.h"

using namespace Eigen;

//! class for computing pose from 3D-2D line segment matching
class PnL
{
public:
	PnL();
	~PnL()
	{
	}

	//! compute rotation transformation from world to camera
	//! Mathematical explanation can be found in the first paper mentioned above
	bool rotationWorldtoModel(const std::vector<Matrix<double, 6, 1> > &v3Lines, Matrix3d &Rmw);
	

	//! the main function that performs the rotation matrix computation between the model and camera
	bool computeRotationP3L(const std::vector<Matrix<double, 6, 1> > &v3Lines,
		const std::vector<Matrix<double, 4, 1> > &v2Lines,
		const Matrix<double, 3, 3> &K, Matrix3d &Rcm);
	
	
	//! generate the arbitrary rotation matrix R_hat in Rcm=R_hat*Rot(X,alpha)*Rot(Z,beta)
	//! inputs n1 = normal to the plane in camera coordinate generated by the line l1 on the image plane and Center of projection C
	//! input m1 = unit direction vector for the 3D line L1 in world coordinate
	//! first column of the rotation matrix is n1, 
	bool generateRotMat(const Vector3d &n1, const Vector3d &m1, Matrix3d &R_);
	

	//! construct the coefficient matrix from the relation
	//! n1cTv1c=n1cT*Rcm*v1m
	//! n2cTv2c=n2cT*Rcm*v2m
	//! v1 and v2 are line directions in the model coordinate
	//! coefficients are generated using matlab symbolic toolbox. 
	//! TODO clean up the code. For now it works
	void constructPolynomCoeffs(const Matrix3d &R_, const Vector3d &n1_,
		const Vector3d &n2_, const Vector3d &v1_,
		const Vector3d &v2_);
	
	//!compute the roots of the 8th order polynomial
	bool computeRoots();

	
	//!compute translation once the rotation is known
	bool computeTranslation(const Matrix3d &R, const Vector3d &n0,
		const Vector3d &n1, const Vector3d &n2,
		const Vector3d &P0, const Vector3d &P1,
		const Vector3d &P2, Vector3d &t);
	
protected:
	Eigen::Matrix<double, 9, 1> coeffVector;
	Eigen::PolynomialSolver<double, 8> pSolver;
	std::vector<double> realRoots;
};

#endif